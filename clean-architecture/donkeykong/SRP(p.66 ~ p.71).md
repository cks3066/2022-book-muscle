# SRP(Single Responsibility Principle)

단일 책임 원칙은 모든 모듈이 하나의 일만 해야한다는 의미로 받아들이기 쉽다. 하지만 이는 단순한 리패ㄱ터링 원칙 중 하나일 뿐이다. SRP는 다음과 같이 기술되어 왔다.

> 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.

여기서 ‘변경의 이유'란 바로 이들 사용자와 이해관계자를 가리킨다. 바꿔말하면 다음과 같다.

> 하나의 모듈은 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다.

위의 상황에서 사용자와 이해관계자는 올바르지 않다. 시스템이 동일한 방식으로 변경되기를 원하는 사용자나 이해관계자가 두 명 이상일 수도 있기 때문이다. 때문에 이런 집단을 액터라고 부르겠다.

> 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

그렇다면 ‘모듈'은 무슨 뜻일까? 모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다.

‘응집된'이라는 단어가 바로 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.

아마도 이 원칙을 이해하는 가장 좋은 방법이 이 원칙을 위반하는 징후들을 살펴보는 것이다.

### 징후 1: 우발적 중복

```jsx
class Employee{

	calculatePay(){
		// 회계팀에서 CFO 보고를 위해 사용
	}

	reportHours(){
		// 인사팀에서 사용, COO 보고를 위해 사용
	}

	save(){
		// 데이터베이스 관리자가 기능 정의, CTO 보고를 위해 사용
	}
}
```

위의 class는 CFO, COO, CTO 총 3명의 액터가 를 책임지기 때문에 단일 책임 원칙을 위반하고 있다. 이 결합으로 인해 CFO 팀에서 결정한 조치가 COO팀이 의존하는 무언가에 영향을 줄 수 있다.

### 징후 2: 병합

소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생하리라고 짐작하기는 어려운 일이 아니다. 특히 이들 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 확실히 더 높다.

만약 CTO팀에서 Employee 테이블 스키마를 수정하기로 하고 동시에 COO 팀에서는 reportHours메소드의 보고서 포맷을 변경하기로 결정했다고 해보자.

두 요구사항을 동시에 수정한다면 이는 필연적으로 충돌이 발생하여 병합이 발생한다. 서로가 요구하는 바가 서로의 예상과는 빗나가는 결과를 이끌어내게 된다. 때문에 병합에는 항상 위험이 뒤따르게 된다.

이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.

### 해결책

이 문제의 해결책은 다양하다. 가장 간단한 방법은 메서드를 모드 각기 다른 클래스로 이동시키는 방식이다.

```jsx
class PayCalculator{
	calcuatePay(){}
}

class HourReporter{
	reportHour(){}
}

class EmployeeSaver{
	saveEmployee(){}
}

const employeeData = {
	...
}
```

EmployeeData를 세개의 클래스가 공유하도록하여 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함한다. 세 클래스는 서로의 존재를 몰라야 한다.

하지만 위처럼 행한다면 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 게 단점이다. 이러한 난관에서 빠져나올때 흔히 쓰는 기법이 퍼사드 패턴이다.

```jsx
class EmployeeFacade{
	constructor(){
		this.data = employeeData;
		this.payCalculator = new PayCalculator();
		this.employeeSaver = new EmployeeSaver();
	}
	calculatePay(){
		this.payCalculator.calculatePay();
	}
	reportHours(){
		this.payCalculator.method();
		this.employeeSaver.method();
	}
	save(){
		this.employeeSaver.saveEmployee();
	}
	
}
```

이처럼 여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가 된다. 해당 유효범위 바깥에서는 이 가족에게 감춰진 식구가 있는지를 전혀 알 수 없다.

### 결론

단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다. 컴포넌트 수준에서는 공통 폐쇄원칙이 된다. 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다.