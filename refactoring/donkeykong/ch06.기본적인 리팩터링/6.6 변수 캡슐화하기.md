# 6. 변수 캡슐화하기

## 배경

함수는 데이터보다 다루기가 수월하다. 함수를 사용한다는 건 대체로 호출한다는 뜻이고, 함수 이름을 바꾸거나 다른 모듈로 옮기기는 어렵지 않다. 여차하면 기존 함수를 그대로 둔 채 전달함수로 활용할 수도 있기 때문이다.

반면 데이터는 함수보다 다루기가 까다롭다. 데이터는 참조하는 모든 부분을 한 번에 바꿔야 코드가 제대로 작동한다. 짧은 함수 안의 임시 변수처럼 유효범위가 아주 좁은 데이터는 어려울 게 없지만, 유효범위간 넓어질수록 다루기 어려워진다.

캡슐화는 데이터를 변경하고 사용하는 코드를 감시할 수 있는 확실한 통로가 되어주기 때문에 데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼어넣을 수 있다.

객체 지향에서는 객체의 데이터를 항상 private으로 해야한다고 강조하고 있다. 클래스 안에서 필드를 참조할 때조차 접근자를 통하게 하는 자가 캡슐화를 주장하는 사람도 있지만 이정도로 클래스가 크다면 클래스를 더욱 잘게 쪼개는게 낫다.

## 절차

1. 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
2. 정적 검사를 수행한다.
3. 변수를 직접 참조하던 부분은 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나씩 바꿀 때마다 테스트한다.
4. 변수의 접근 범위를 제한한다.
5. 테스트한다.
6. 변수 값이 레코드라면 레코드 캡슐화하기를 적용할지 고려해본다.

### 예시

1. 

```jsx
let defaultOwner = {firstname: "동혁", lastName: "주"};

woowa.owner = defaultOwner;//데이터 참조
defaultOwner = {firstname:"디디에", lastName:"드록바"};// 데이터 갱신
```

1. 데이터 읽고 쓰는 함수를 정의한다.

```jsx
function getDefaultOwner() { return defaultOwner; }
function setDefaultOwner(args) { defaultOwner = arg;} 
```

1. get, set 함수로 데이터 참조, 갱신 로직을 대체한다.

2. 하나씩 바꿀때 마다 테스트한다.

3. 모든 참조를 수정했다면 변수의 가시범위를 제한한다.

   1. 변수와 접근자 메서드를 같은 파일로 옮기고 접근자만 노출시키면 된다.

   가장 기본적인 변수 캡슐화지만 위와 같은 경우는 문제가 있다. 위와 같이 한다면 데이터로의 접근이나 구조 자체를 다시 대입하는 행위는 제어 할 수 있지만 필드 값을 변경하는 일은 제어할 수 없다.

   ```jsx
   const owner1 = getDefaultOwner();
   const owner2 = getDefaultOwner();
   owner2.firstName = "준찌"
   console.log(owner1.firstName)    // 준찌
   ```

   위 방법의 해결책은 두가지다.

   1. 데이터의 복제본을 반환한다.

   ```jsx
   function getDefaultOwner() {return Object.assign({},defaultOwnerData);}
   ```

   복제본을 반환하면 데이터를 얻을 순있지만 원본에는 영향을 주지 못한다. 하지만 이 경우에는 원본 변경하기를 원하는 클라이언트가 있을 때 변경을 할 수 없다.

   1. 레코드 캡슐화하기

   ```jsx
   class Person{
   	#lastName;
   
   	#firtstName;
   
   	constructor(data){
   		this.#lastName = data.lastName;
   		this.#firstName = data.firstName;
   	}
   
   	get lastName() { return this.#lastName; }
   
   	...
   
   }
   ```

   여기서 명심할 점은 복제본 만들기와 클래스로 감싸는 방식은 레코드 구조에서 깊이가 1인 속성들까지만 효과가 있다. 더 깊이 들어가면 복제본과 객체 래핑 단계가 더 늘어나게 된다.

캡슐화의 구체적인 대상과 방법은 캡슐화할 데이터를 사용하는 방식과 그 데이터를 어떻게 변경하려는 지에 따라 달라진다. 하지만 분명한 사실은 데이터의 사용 범위가 넓을수록 적절히 캡슐화 하는게 좋다는 것이다.