# 리팩토링 CH02. 리팩토링 원칙



## 리팩터링 정의

리팩터링은 명사로도 쓸 수 있고, 동사로도 쓸 수 있다.

- 명사의 경우 : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
  - ex) 함수 추출하기, 조건부 로직을 다형성으로 바꾸기
- 동사의 경우: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.
  - ‘겉보기 동작' 이란 리팩터링하기 전과 후의 코드가 똑같이 동작해야한다.
  - 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다.

리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이지 성능과는 무관하다. 성능을 목표로 하는 것은 성능 최적화 이다.

기능 추가와 리팩터링은 교차적으로 이루어져야 한다. 기능 추가시에는 오로지 새 기능에만 집중하고 기존 코드는 손을 대서는 안된다. 리팩터링 할때는 오로지 코드 재구성에만 집중하고 기능 추가는 절대로 하지 않는다.

## 리팩터링의 이유

### 1. 리팩터링하면 소프트웨어 설계가 좋아진다.

리팩터링을 하지 않을경우 소프트웨어의 내부 설계가 썩기 쉬워진다. 이는 코드 구조의 붕괴를 일으키고 코드 구조가 무너지기 시작하면 코드만으로 설계를 파악하기 어려워진다.

설계가 나빠지면 코드는 길어지고 같은 일을 하는 코드가 여러 곳에 등장한다. (이는 중복 코드 제거를 통해 해결할 수 있다.) 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있게 된다.

### 2. 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

프로그래밍은 컴퓨터에게 시키려는 일을 코드로 작성하는 것이다. 결국 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야한다.

프로그램의 동작에만 신경을 쓰면 나중에 그 코드를 다룰 개발자를 배려하지 못하는 것이다. 코드의 목적이 잘 드러나게 내 의도를 명확하게 작성할 수 있어야 한다.

기억에 의존하지말고 코드에 의존하자.

### 3. 리팩터링하면 버그를 쉽게 찾을 수 있다.

리팩터링을 하게 되면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다. 프로그램의 구조를 명확히 다듬게 되면 예측이 확증이 되고 이는 버그를 쉽게 찾게되는 지름길이 된다.

### 4. 리팩터링하면 프로그래밍 속도를 높일 수 있다.

리팩터링을 하게되면 리팩터링을 하는 시간이 추가가 되기 때문에 프로그래밍의 전체적인 시간이 증가한다고 오해하기가 쉽다. 하지만 리팩터링을 하게되면 내부 설계와 가독성이 개선되고 버그가 줄어든다.

프로그래밍의 끝이 없다고 생각한다. 때문에 리팩터링을 하지않을경우 초기에는 그 속도가 빠를 수 있지만 시간이 지날수록 기능하나를 추가하는데 시간이 훨씬 오래 걸리게 된다. 게다가 기능을 추가하면서 버그가 발생하고 이를 해결하는데 후러씬 시간이 걸리게 된다.

내부 설계가 잘된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 모듈화가 잘되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다. 따라서 확장성의 면에 있어서 그 속도의 차이는 어마어마할 것 같다.

## 언제 리팩터링 해야 할까?

이 책의 저자(마틴 파울러)는 보통 거의 한 시간 간격으로 리팩터링을 진행한다고 한다. 이번 미션을 진행하면서 보통 스텝이 끝나고 리팩토링하는 방향으로 했는데 고쳐야 할 필요가 있는 것 같다.

- 3의 법칙(돈 로버츠)
  1. 처음엔 그냥 한다.
  2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽지만), 일단 계속 진행한다.
  3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 이 시점에서 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.

버그를 잡을 때도 오류를 일으키는 코드가 여러 군데 퍼져있을 때 한 곳으로 합친 후 작업하면 여러 오류를 한 번에 해결할 수 있게 된다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드를 계속 읽어보면서 리팩터링의 여지를 살펴봐야한다. 리팩터링을 하게 되면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그 후 테스트를 통해 내 생각에 대한 검증을 맞게 되는 것이다.

코드를 분석할 때 리팩터링을 하면 그렇지 않았을 때보다 더 깊은 수준까지 가게 된다고 한다.

### 쓰레기 줍기 리팩터링

쓰레기가 나뒹굴게 방치하면 나중에 일을 방해하도록 내버려두는 것과 같다. 간단히 수정할 것은 바로 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음(주석을 이용하면 좋을 것 같다.) 하던 일을 끝내고 나서 처리해야 한다. 이것이 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링이다.

### 계획된 리팩터링과 수시로 하는 리팩터링

리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 이 책의 저자는 리팩터링 시간을 따로 일정에 잡아두지 않고 다른 일을 하는 도중에 처리 한다고 한다. 리팩터링은 과거의 실수를 바로 잡는 것이 아니다. 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야한다. 어제는 적합했던 코드가 오늘 다른 작업에는 맞지 않을 수 있다. 리팩토링이 과거의 자신을 부정하는 행위는 아닌 것이다. 결국 완벽한 코드라는 것은 없는 것 같다.

그렇다고 계획딘 리팩터링이 무조건 나쁘지는 않다. 리팩터링에 소할했다고 느낄 때 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요도 있다. 하지만 계획된 리팩터링의 범위를 최대한 줄이고 기회가 될 때마다 해야한다.

### 오래 걸리는 리팩터링

리팩터링은 대부분 몇 분 길면 몇 시간 정도 걸린다. 하지만 물론 몇 주까지 소요되는 대규모 리팩터링도 있다. 이 책의 저자는 이런 상황에 처하더라도 팀 전체가 리팩터링에 매달리는 것은 아니라고 주장한다. 리팩토링이란 앞서 말한대로 일부를 변경해도 모든 기능이 항상 올바르게 동작하는 것이기 때문에 조금씩 해결해나가는 것을 더욱 추천한다.

### 코드 리뷰에 리팩터링 활용하기

작성자와 나란히 앉아서 코드를 훑어가는 리팩토링을 추천한다. 이것이 바로 짝프로그래밍이 되는 것 같다.

### 리팩터링하지 말아야 할 때

- 외부 API 다루듯 호출해서 쓰는 코드일 떄
- 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때
  - 이는 판단하기가 굉장히 어렵기 때문에 경험이 뒷받침 되야한다.



## 리팩터링시 고려할 문제

리팩터링이 아무리 좋다고 해서 문제가 없는 것은 아니다. 이러한 문제들이 언제 발생하고 어떻게 대처해야 할지 반드시 알고 있어야 한다.

### 새 기능 개발 속도 저하

지난 번에 포스트한 글에서 봤듯이 많은 사람들이 리팩터링 때문에 새 기능을 개발하는 속도가 느려진다고 여기지만, 리팩터링의 궁극적인 목적은 궁극적인 속도를 높이는 데 있다.

> *리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.*

하지만 역시 이는 절대적인 것이 아니다. 리팩터링이 필요해 보이지만, 추가하려는 새 기능이 아주 작아서 기능 추가부터 하고 싶은 상황에 마주칠 수 있다. 이럴 때는 경험이 중요한데 경험이라는 것은 절대적인 것이 될 수 없기 때문에 저자는 준비를 위한 리팩터링을 추천한다. 이는 기능을 추가하는 시간을 현저히 줄여주고 구조를 더욱 탄탄히 만들어 준다.

많은 개발자가 쉽게 범하는 오류는 리팩터링을 ‘클린 코드'나 ‘바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 것이다. **리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않고 오로지 경제적인 이유로 하는 것이다.**  리팩터링은 개발 기간을 단축하고자 하는 것이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.

### 코드 소유권

이 책의 저자는 코드 소유권을 작은 단위로 작은 단위로 나눠 엄격히 관리하는 데 반대하고 있다. 이는 리팩터링을 주저하게 만들고 책임을 전가하게 만들 것이다. 저자가 추천하는 방식은 코드 소유권을 팀에 두는 것이다. 팀원 이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다. 각자가 책임이 있는 영역이 있을 수도 있지만 이는 맡은 영역의 변경사항을 관리하라는 뜻이고 다른 사람이 수정하지 못하게 막으라는 뜻이 아니다.

### 브랜치

프로젝트를 진행하다 보면 브랜치를 나누는 많은 브랜치 전략들을 마주하게 된다. 보통 버전 관리 시스템을 사용하여 팀원마다 브랜치를 하나씩 맡아서 작업하다가, 결과물이 어느 정도 쌓이면 마스터 브랜치에 통합해서 다른 팀원과 공유하는 것이다.

이런 식으로 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 통합하기가 어려워진다. 만약 4주간 작업한 브랜치들을 통합하려면 2주간 작업한 브랜치들을 통합할 때보다 적어도 두 배 이상 들 것이다. 이 때문에 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다고 주장하는 사람이 많다. 저자는 더 짧아야 한다고 주장하고 이러한 방식을 지속적인 통합(CI), 또는 트렁크 기반 개발(TBD)라 한다.

> **지속적 통합(CI)** 자동화된 빌드 및 테스트가 수행된 후, 개발자가 코드 변경 사항을 중앙 리포지토리에 정기적으로 병합하는 [데브옵스](https://aws.amazon.com/ko/devops/) 소프트웨어 개발 방식입니다. 지속적 통합은 소프트웨어 릴리스 프로세스 중 빌드 또는 통합 단계를 주로 가리키며, 자동화 구성 요소(예: CI 또는 빌드 서비스)와 문화적 구성 요소(예: 빈번하게 통합하도록 학습) 모두를 포함합니다. 지속적 통합의 핵심 목표는 버그를 신속하게 찾아 해결하고, 소프트웨어 품질을 개선하고, 새로운 소프트웨어 업데이트를 검증 및 릴리스하는 데 걸리는 시간을 단축하는 것입니다.

> 출처 : [AWS 지속적인 통합](https://aws.amazon.com/ko/devops/continuous-integration/)

CI는 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다. 이렇게 하면 다른 브랜치들과의 차이가 크게 벌어지는 브랜치가 없어져서 머지의 복잡도를 상당히 낮출 수 있다. 하지만 CI에서는 그 대가가 따르는데 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야한다.

CI의 장점은 머지의 복잡도도 줄일 수 있지만 가장 큰 이유는 리팩터링과 궁합이 좋기 때문이다. 리팩터링을 하다보면 자잘자잘하게 수정하는 부분이 많은데 이렇게 되면 머지 과정에서 충돌이 생기기 쉽다. 켄트 벡이 CI와 리팩터링을 합쳐서 익스트림 프로그래밍(XP)을 만든 이유도 바로 두 기법의 궁합이 잘 맞기 떄문이다.

> **익스트림 프로그래밍**

([영어](https://ko.wikipedia.org/wiki/영어): eXtreme Programming, **XP**)는 [켄트 백](https://ko.wikipedia.org/wiki/켄트_백) 등이 제안한 [소프트웨어](https://ko.wikipedia.org/wiki/소프트웨어) 개발 방법이다. 개발 문서 보다는 소스코드를, 조직적인 개발의 움직임 보다는 개개인의 책임과 용기에 중점을 두는 경향이 크다. 켄트 백은 XP를 이끄는 가치와 원칙에 대해서도 강조했다. XP에서 실천 방법에만 집중하고 가치와 원칙을 무시하면 제대로 XP를 실천하고 있다 하기 힘들 것이다. 원칙은 가치와 실천 방법을 잇는 다리 같은 것이다.

출처: [위키피디아](https://ko.wikipedia.org/wiki/익스트림_프로그래밍)

> 

### 테스팅

만약 리팩터링을 하면서 실수를 저지른다면 어떻게 될까? 리팩터링은 단계별 변경 폭이 작아서 도중에 발생한 오류의 원인이 도리만한 코드 범위가 넓지 않다. 원인을 못 찾더라도 버전 관리 시스템을 이용하여 갖아 최근에 정상 작동하던 상태로 되돌리면 되지만 여기서 중요한 것은 오류를 빨리 잡는다는 것이다. 이렇게 하려면 코드의 다양한 측면을 검사하는 테스트 스위트가 필요하다.

자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다. 실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문이다. 테스트 주기가 짧다면 단 몇 주라만 비교하면 되며, 문제를 일으킨 부분이 그 몇 줄 안에 있기 때문에 버그를 훨씬 쉽게 찾을 수 있다.

대규모 레거시 시스템을 리팩토링 할때도 테스트 보강이 가장 중요하다. 하지만 이는 쉽지 않을 것이다.

### 리팩터링, 아키텍처, 애그니(YAGNI)

리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는데  있다. 그렇다고 아키텍처에 너무 의존적이면 안된다. 처음부터 아키텍처를 복잡하게 구성하고 함수를 정의할 때 범용적으로 사용하려고 노력하면 당장의 쓰임에 비해 함수가 너무 복잡해지게 된다.

리팩터링을 활용하면 다르게 접근할 수 있다. 앞으로 어느 부분에 유연성이 필요하고 어떻게해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다.

야그니(YAGNI:”you aren’t going to need it”의 줄임말) 점진적 설계는 아키텍처를 전혀 고려하지 말라는 뜻은 아니다. 리팩터링으로 변경하기 어려워서 미리 생각해두면 시간이 절약되는 경우도 얼마든지 있다. 그 균형이 중요한 것인데 이 저자는 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 낫다고 생각하는 편이다.(무조건적으로 구조를 명확하게 정하고 이를 따라갈 필요는 없고 필요성을 느낄 때 분리하는 것을 추천하는 것 같다.)



> 팀이 따르는 실천법에 따라 리팩터링의 효과가 크게 달라진다. 실제로 리팩터링이 퍼지기 시작한 것도 익스트림 프로그래밍(XP)에 도입됐기 때문이다. XP의 두드러진 특징은 지속적인 통합, 자가 테스트 코드, 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스라는 점이다. 참고로 테스트 코드와 리팩터링을 묶어서 테스트 주도개발이라 한다.





## 리팩터링과 소프트웨어 개발 프로세스

최초의 애자일 소프트웨어 방법론 중 하나로 등장한 XP는 그 후 수년에 걸쳐 애자일의 부흥을 이끌었다. 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.

**리팩터링의 토대**

1. 자가테스트코드
   - 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다.
2. 지속적 통합(CI)
   - 지속적 통합을 적용하면 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있다.

추측에 근거한 수많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기가 훨씬 쉽다. 위를 잘 지키면 요구사항 변화에 재빠르게 대응하고 안정적인 선순환 구조를 코드베이스에 심을 수 있다.

## 리팩터링과 성능

리팩터링을 하면 프로그램 성능이 느려질까봐 많은 사람들이 걱정하는데 이 책의 저자는 소프트웨어를 이해하기 쉽게 만들기 이해 속도가 느려지는 방향으로 수정하는 경우가 많다.

**리팩터링하면 소프트웨어가 느려질 수도 있지만 동시에 성능을 튜닝하기는 더 쉬워진다.**

**빠른 소프트웨어를 작성하는 방법**

1. 시간 예산 분배 방식
   - 하드 리얼타임 시스템에서 많이 사용.
   - 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당.
   - 심장 박동 조율기 처럼 데이터가 늦게 도착하면 안 되는 시스템에서는 중요
   - but, 사내 정보 시스템과 같은 부류에는 맞지 않다.
2. 끊임없이 관심을 기울이기
   - 직관적이어서 흔히 사용하는 방식이지만 실제 효과는 변변치 않다.
   - 성능을 개선하기 위해 코드를 수정하다 보면 프로그램을 다루기 어려운 형태로 변하기 쉽고, 결국 개발이 더뎌지기 때문이다.
3. **의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는데 집중**
   - 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다.
   - 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없기 때문에 시간 낭비인 셈이다.
   - 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 찾아내 개선하는 방식
   - 때문에 리팩터링이 이런 식의 최적화에 도움이 된다.
     - 성능 튜닝에 투입할 시간을 벌 수 있다.
     - 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다.