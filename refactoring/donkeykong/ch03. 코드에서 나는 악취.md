# 리팩터링 CH3. 코드에서 나는 악취

리팩터링이 중요하다는 것은 어느정도 알았다. 리팩터링을 어떻게 하는지는 후에 설명한다. 그렇다면 리팩터링을 어느 곳에서 해야할까? 리팩터링이 필요한, 때로는 아주 절실한 코드들에 일정한 패턴이 있다.

## 기이한 이름

코드는 단순하고 명료하게 작성해야 한다. 코드를 명료하게 표현하는 데 가장 중요한 요소 중 하나는 바로 ‘이름’이다. 이름만 보고도 각각이 무슨일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 신경써서 이름을 지어야 한다.

- 함수 선언 바꾸기
- 변수 이름 바꾸기
- 필드 이름 바꾸기

마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

## 중복 코드

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

- 함수추출하기: 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우
- 문장 슬라이드하기: 코드가 비슷하긴 한데 완전히 똑같지 않을때
- 메서드 올리기: 같은 부모로부터 파생된 서브클래스들에 코드가 중복되어 있는 경우

## 긴 함수

프로그래밍 초창기부터 사람들은 함수가 길수록 이해하기 어렵다는 사실을 깨달았다. 우리는 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 함수 이름은 동작 방식이 아닌 ‘의도'가 드러나게 짓는다. 무엇을 하는지를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.

- 함수 추출하기: 함수를 짧게 만드는 작업의 99%
- 임시변수를 질의함수로 바꾸기: 임시 변수의 수를 줄이는 경우
- 매개변수 객체 만들기, 객체 통째로 넘기기: 매개변수의 수를 줄이기
- 함수를 명령으로 바꾸기: 위 리팩터링들을 적용해도 여전히 임시 변수와 매개변수가 많을 때
- 조건문 분해하기, 조건부 로직을 다형성으로 바꾸기
- 반복문 쪼개기

## 긴 매개변수 목록

매개변수 목록이 길어지면 그 자체로 이해하기 어렵다.

- 매개변수를 질의 함수로 바꾸기: 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 경우
- 객체 통째로 넘기기: 사용 중인 데이터 구조에서 값들을 뽑아 각가을 별개의 매개변수로 전달하는 코드일 경우
- 매개변수 객체 만들기ㅣ 항상 함께 전달되는 매개변수가 존재하는 경우
- 플래그 인수 제거하기: 함수의 동작방식을 정하는 플래그 역할의 매개변수가 존재하는 경우
- 여러 함수를 클래스로 묶기

## 전역 데이터

전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다. 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤 패턴에서도 같은 문제가 발생한다.

- 변수 캡슐화하기: 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 가장먼저 적용

## 가변 데이터

데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있다. 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동한다.

함수형 프로그래밍에서는 데이터는 절대 변하지 않고 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.

- 변수 캡슐화하기: 정해 놓은 함수를 거쳐야만 값을 수정할 수 있도록 하기
- 변수 쪼개기: 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우
- 문장슬라이드하기, 함수 추출하기: 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리
- 질의 함수와 변경 함수 분리하기
- 세터 제거하기
- 파생 변수를 질의 함수로 바꾸기
- 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기
- 참조를 값으로 바꾸기

## 뒤엉킨 변경

코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다. 이렇게 할 수 없다면 뒤엉킨 변경과 산탄총 수술 중 하나가 나타난다.

뒤엉킨 변경은 [단일 책임 원칙(SRP)](https://blog.itcode.dev/posts/2021/08/13/single-responsibility-principle)이 제대로 지켜지지 않을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.

- 단계 쪼개기
- 함수 옮기기
- 클래스 추출하기

## 산탄총 수술

코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때

- 함수 옮기기, 필드 옮기기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 단계 쪼개기
- 함수 인라인하기
- 클래스 인라인하기

## 기능 편애

프로그램을 모듈화할 때는 코드를 여러 영역으로 나누 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다. 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새다.

- 함수 옮기기: 실행 과정에서 외부 객체의 개터 메서드 대여섯 개를 호출하도록 작성된 함수인 경우
- 함수 추출하기: 함수의 일부에서만 편해하는 경우

## 데이터 뭉치

몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 한다.

- 클래스 추출하기
- 매개변수 객체 만들기, 객체 통째로 넘기기: 메서드 시그니처에 있는 데이터 뭉치

새로 만든 객체의 필드 중 일부만 사용하더라도 걱정할 필요 없다. 새 객체로 뽑아낸 필드가 두 개 이상이기만 해도 확실히 예전보다 나아진다.

## 기본형 집착

프로그래머 중에는 자신에게 주어진 문제에 딱 맞는 기초타입(화페, 좌표, 구간 등)을 직접 정의하기를 몹시 꺼리는 사람이 많다. 그래서 금액을 그냥 숫자형으로 계산하거나, 물리량을 계산할 때도 밀리미터나 인치 같은 단위를 무시하고 처리하는 코드가 많다.

- 기본형을 객체로 바꾸기
- 타입 코드를 서브클래스로바꾸기, 조건부 로직을 다형성으로 바꾸기: 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였을 경우

## 반복되는 switch문

현재 다형성이 널리 자리 잡아서 단순히 switch문을 썼다고 해서 자동으로 검토 대상은 되지는 않는다. 이제는 똑같은 조건부 로직이 여러 곳에서 반복해 등장하는 코드에 집중하자.

- 조건부 로직을 다형성으로 바꾸기

## 반복문

- 반복문을 파이프라인으로 바꾸기: 시대에 걸맞지 않은 반복문 제거 필터나 맵같은 파이프라인 연산을 사용한다.

## 성의 없는 요소

우리는 코드의 구조를 잡을 때 프로그램 요소(함수, 클래스, 인터페이스 등)를 이용하는 걸 좋아한다. 그래야 그 구조를 변형하거나 재활용할 기회가 생기고, 혹은 단순히 더 의미 있는 이름을 가졋기 떄문이다. 그렇지만 그 구조가 필요 없을 때도 있다.

- 함수 인라인하기
- 클래스 인라인하기
- 계층 합치기

## 추측성 일반화

나중에 필요할거야 라는 생각으로 당장은 필요 없는 모든 종류의 후킹포인트와 특이 케이스 처리 로직을 작성해둔 코드

- 계층 합치기
- 함수 인라인하기, 클래스 인라인하기
- 함수 선언 바꾸기
- 죽은 코드 제거하기

## 임시 필드

특정상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 하지만 객체를 가져올 때는 당연히 모든 필드가 채워져

있으리라 기대하는 게 보통이라, 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다.

- 클래스 추출하기: 덩그러니 떨어져 있는 필드를 발견할 경우
- 함수 옮기기: 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아 넣는다.
- 특이 케이스 추가하기: 필드들이 유효하지 않을 때를 위한 대안클래스 만들기

## 메시지 체인

메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.

- 위임숨기기
- 함수 추출하기

## 중개자

객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 캡슐하가 있다. 캡슐화하는 과정에서는 위임이 자주 활용된다. 하지만 이렇게 하는 것도 지나치면 문제가 된다. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임한다면 그 클래스의 존재이유가 사라질 것이다.

- 중개자 제거하기

## 내부자 거래

모듈 사이의 데이터 가래가 많으면 결합도가 높아진다. 그 양을 최소로 줄이고 모두 투명하게 처리해야한다.

- 함수옮기기, 필드 옮기기: 사적으로 처리하는 부분 줄인다.
- 위임 숨기기: 여러 모듈이 같은 관심사를 공유하는 경우
- 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임을 바꾸기

## 거대한 클래스

한 클래스가 너무 많은 일을 하려다 보면 필드 수가 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.

- 클래스 추출하기
- 슈퍼클래스 추출하기
- 타입 코드를 서브 클래스로 바꾸기

## 서로 다른 인터페이스의 대안 클래스들

클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다. 단 교체하려면 인터페이스가 같아야 한다.

- 함수 선언 바꾸기
- 함수 옮기기
- 슈퍼클래스 추출하기

## 데이터 클래스

데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다. 그저 데이터 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰 대가 많다.

- 레코드 캡슐화하기
- 세터 제거하기
- 함수 옮기기
- 함수 추출하기

## 상속 포기

서브클래스는 부모로부터 메서드와 데이터를 물려받는다. 하지만 부모의 유산을 원치 않거나 필요 없다면 어떻게 해야 할까?

- 메서드 내리기, 필드 내리기: 물려받지 않을 부모 코드를 모조리 새로 ㅏㅁㄴ든 서브클래스로 넘긴다.

## 주석

주석은 악취가 아닌 향기를 입힌다. 문제는 주석을 탈취제처럼 사용하는 데 있다. 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 떄문인 경우가 많다.

- 함수 추출하기
- 함수선언하기
- 어서션 추가하기

뭘 할지 모를 때라면 주석을 달아두면 좋다. 현재 진행 상황뿐만 아니라 확실하지 않은 부분에 주석을 남긴다.