# 객체지향의 사실과 오해
## 01. 협력하는 객체들의 공동체
- 객체지향의 목표는 실세계를 모방하는 것이 아니다. 오히려 새로운 세계를 창조하는 것이다.
- 음료 주문은 `손님`이 커피를 주문하고, `캐시어`가 주문을 받고, `바리스타`가 커피를 제조하는 과정을 거친 후에야 완료된다.커피를 주문하고 제조하는 과정은 `역할`, `책임`, `협력`이라는 사람의 일상 속에 항상 스며들어 있는 세 가지 개념이 한데 어울려 조화를 이루며 만들어 낸 것이다.
  - 이처럼 `커피 주문`이라는 `협력`에 참여하는 모든 사람들은 커피가 정확하게 주문되고 주문된 커피가 손님에게 정확하게 전달될 수 있도록 맡은 바 `역할`과 `책임`을 다하고 있다.
### 요청과 응답으로 구성된 협력
- 요청은 연쇄적으로 발생한다. 응답 역시 요청의 방향과 반대 방향으로 연쇄적으로 전달된다. 
- [요청] `손님` --`커피 주문 요청`--> `캐시어` --`커피 제조 요청`--> `바리스타`
- [응답] `손님` <--`커피 완성(진동벨 울림)`-- `캐시어` <-- `커피 완성 알림` <-- `바리스타
### 역할과 책임
- `역할`이라는 단어는 의미적으로 `책임`이라는 개념을 내포한다.
- 여러 사람이 동일한 `역할`을 수행할 수 있다.
  - ex, 어떤 `캐시어`가 그만두더라도 다른 사람을 `캐시어`로 고용하여 역할에 따른 책임을 수행하게 할 수 있다.
- `역할`은 `대체 가능성`을 의미한다.
  - ex, 손님 입장에서 `캐시어`가 누가 되든 상관 없다.
- `책임`을 수행하는 방법은 자율적으로 선택할 수 있다.
  - ex, 바리스타는 커피 제조라는 메시지에 응답하기 위해 자신만의 자율적인 방법에 따라 커피를 제조할 수 있다.
  - 요청을 받은 사람들은 요청을 처리하는 방법을 자유롭게 선택할 수 있다. 이처럼 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 `다형성(polymorphsim)`이라고 한다.
- 한 사람이 동시에 여러 `역할`을 수행할 수 있다.
  - ex, 한 사람이 동시에 `캐시어`와 `바리스타` 역할을 동시에 수행할 수도 있다.

### 역할 책임, 협력
- 앞에서 비유한 실세계 커피 주문 과정을 프로그래밍으로 다시 옮겨보자.
- `사람`을 `객체`로, 에이전트의 요청을 `메시지`로, 요청을 처리하는 방법을 `메서드`로 바꾸면, 대부분의 설명을 `객체지향`이라는 문백으로 옮길 수 있다.
- `목표`를 이루기 위해 서로 `협력`하고, `목표`는 더 작은 `책임`으로 분할되고, 책임을 수행할 수 있는 적절한 `역할`을 가진 사람에 의해 수행된다.
  - 즉, 애플리케이션의 기능은 더 작은 `책임`으로 분할되고 `책임`은 적절한 `역할`을 수행할 수 있는 `객체`에 의해 수행된다. 

### 협력 속에 사는 객체
- 객체는 `협력`을 위해 다음 두 가지 특징에서 균형을 갖춰야 한다.
  - 첫째, 객체는 충분히 `개방적`이어야 한다. 혼자 다하려고 하면 결국 내부 복잡도에 의해 자멸한다.
  - 둘째, 객체는 충분히 `자율적`이어야 한다. 즉, 다른 객체의 명령에 복종하는 수동성이 아니라 단지 요청에 응답하는 것이다.

### 상태와 행동을 함께 지닌 자율적인 객체
- 객체의 `자율성`은 객체의 `내부`와 `외부`를 명확히 `구분`하는 것으로부터 나온다.
  - 객체는 다른 객체가 `무엇(what)`을 수행하는지는 알 수 있지만, `어떻게(how)` 수행하는지에 대해서는 알 수 없다.
  - 객체지향의 세계에서는 한 가지 의사소통 수단으로서 오직 `메시지`만이 존재한다. 한 객체가 다른 객체에게 요청하는 것을 `메시지를 전송`한다고 말하고, 다른 객체로부터 요청을 받는 것을 `메시지를 수신`한다고 말한다.
### 메서드와 지율성
- 객체가 수신된 메시지를 처리하는 방법을 `메서드`라고 한다.
- `메시지`와 `메서드`의 분리는 객체의 협력에 참여하는 객체들 간의 자율성을 증진시킨다.
- 외부의 요청이 무엇인지를 표현하는 `메시지`와 요청을 처리하기 위한 구체적인 방법인 `메서드`를 분리하는 것은 객체의 `자율성`을 높이는 핵심 메커니즘이다. 이것은 `캡슐화` 개념과도 관련있다.

### 객체를 지향하라(클래스는 껍데기일뿐...껍데기는 가라)
- 클래스가 객체지향 프로그래밍 언어의 관점에서 매우 중요한 구성요소(construct)인 것은 분명하지만 객체지향의 핵심을 이루는 중심 개념은 아니다.
- 특히, 자바스크립트 같은 프로토타입 기반의 객체지향 언어에서는 클래스가 존재하지 않으며 오직 객체만이 존재한다. 프로토타입 기반의 객체지향 언어에서는 `상속` 역시 클래스가 아닌 객체 간의 `위임(delegation)` 메커니즘을 기반으로 한다.
- 즉, 애플리케이션을 `협력하는 객체들의 공동체`가 아닌 `클래스로 구성된 설계도`로 보는 관점은 유연하고 확장 가능한 애플리케이션의 구축을 방해한다.
- 객체지향을 잘하기 위해서는
  - `코드를 담는 클래스의 관점(x)`에서 `메시지를 주고받는 객체의 관점(O)`으로 사고의 중심을 전환하는 것이다.
    - 어떤 `객체`들이 어떤 `메시지`를 주고받으며 협력하는가?
    - 클래스는 단지 객체들의 협력 관계를 코드로 옮기는 도구(껍데기?)에 불과하다.

## 02. 이상한 나라의 객체
- 객체란 인간이 분명하게 인지하고 `구별`할 수 있는 물리적인 또는 개념적인 `경계`를 지닌 어떤 것이다.
- 객체지향 패러담의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 새로운 세계를 창조하는 것이다.
  - 소프트웨어 세계의 전등은 외부의 도움 없이도 "스스로 전원을 켜거나 끌 수 있다".

### 객체, 그리고 이상한 나라
- `이상한 나라의 앨리스` 소설을 이용한 비유와 설명
- 앨리스의 키`(상태)`를 변화시키는 것은 앨리스가 케이크를 먹는 `행동`이다.
  - 앨리스가 한 `행동`의 결과(키가 얼마가 될지)는 앨리스의 `상태`(이전의 키)에 의존적이다.
- 앨리스의 특징 요약
  - 앨리스는 상태를 가지며 상태는 변경 가능하다.
  - 앨리스의 상태를 변경시키는 것은 앨리스의 행동이다.
    - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
    - 행동의 순서가 결과에 영향을 미친다.
  - 앨리스는 어떤 상태에 있더라도 유일하게 식별 가능하다.
### 객체, 그리고 소프트웨어 나라
- 객체(여기선 앨리스)를 `상태(state)`, `행동(behavior)`, `식별자(identity)`를 지닌 실체로 보자.
### 상태
- 왜 상태가 필요한가?
  - 상태를 이용하면 과거의 모든 행동 이력을 설명하지 않고도 행동의 결과를 쉽게 예측하고 설명할 수 있다. 앨리스가 과거에 어떤 행동을 했었는지 모르더라도 앨리스의 키만 알면 문을 통과할 수 있는지 여부를 판단할 수 있다. (즉, 앨리스의 키와 문의 높이라는 두 가지 상태를 통해 문 통과 행동 결과를 예측할 수 있다)
- 상태와 프로퍼티
  - 세상에 존재하는 모든 것들이 객체인 것은 아니다. 분명하게 인식할 수 있어도 객체가 아닌 것이 있다.
    - 앨리스의 `키`와 `위치`는 객체가 아니다. 음료의 케이크의 `양`은 객체가 아니다.
    - 이처럼 그 자체로 독립적인 의미를 갖기보다는 다른 객체의 특성을 표현하는 데 사용되는 것을, 객체의 상태이며 `프로퍼티(property)`라고 한다. 
    - `프로퍼티`는 변경되지 않고 고정되기 때문에, `정적`이다. 반면 `프로퍼티 값(property value)`은 시간의 흐름에 따라 변경되므로 동적이다.

### 행동
- 객체의 상태는 저절로 변경되지 않는다. 객체의 상태를 변경하는 것은 객체의 `자발적인 행동`뿐이다.
- 객체가 취하는 행동은 객체 자신의 상태를 변경시킨며, 이처럼 행동이 상태를 변경시킨다는 것은 행동이 `부수 효과(side effect)`를 초래한다는 것을 의미한다. 
  - 즉, 앨리스가 케이크를 먹는 행위는 `앨리스의 키를 작게 변화시키고`, `케이크의 양을 줄이는` "부수효과"를 야기한다.
- 객체의 행동은 상태에 영향을 받으며, 상태를 변경시킨다.
### 협력과 행동
- 객체의 행동으로 인해 발생하는 결과는 다음 두 가지 부수효과를 발생시킨다.
  - 객체 자신의 상태 변경
  - 행동 내에서 협력하는 다른 객체에 대한 메시지 전송
### 상태 캡슐화
- 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다.
- 상태를 외부에 노출시키지 않고 행동을 경계로 캡슐화하는 것은 결과적으로 객체의 자율성을 높인다. 
### 식별자
- 객체란 인간의 인지 능력을 이용해 식별 가능한 경계를 가진 모든 사물을 의미한다. 객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 것을 의미한다.
### 행동이 상태를 결정한다.
- 초보자들은 상태를 중심으로 객체를 바라보면서, 먼저 객체에 필요한 상태를 결정하고 나중에 그 상태에 필요한 행동을 결정하는데, 이는 설계에 나쁜 영향을 끼친다. 그 이유는 다음과 같다.
- 1. 상태를 먼저 결정할 경우 캡슐화가 저해된다. 
  - 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되어버린다.
- 2. 객체를 협력자가 아닌 고립된 섬으로 만든다.
  - 상태를 먼저 고려하면 협력이라는 문맥에서 벗어난 채 설계하기 쉽다.
- 3. 객체의 재사용성이 저하된다.
  - 상태에 초점을 맞춘 객체는 다양한 협력에 참여하기 어렵다. 

- 따라서 어떤 책임(행동과 관련)이 필요한가를 결정하는 과정이 전체 설계를 주도해야 한다.
  - 즉, `책임-주도 설계(Responsiblity-Driven Design, RDD)`는 협력이라는 문맥 안에서 객체의 `행동`을 생각하도록 도움으로써 응집도 높고 재사용 가능한 객체를 만들 수 있게 한다.
  - 필요한 `협력`을 생각하고 협력에 참여하는 데 필요한 `행동`을 생각한 후, 행동을 수행할 객체의 `상태`를 선택한다. (협력->행동->상태)

### 은유와 객체
  - 의인화
    - 현실 속에서 `수동적인 존재`가 소프트웨어 객체로 구현될 때는 `능동적`으로 변한다. 즉, 소프트웨어 객체의 특징을 `의인화`라고 부른다.
  - 은유
    - 객체지향의 설계자로서 우리의 목적은 현실을 모방하는 것이 아니다. 단지 이상한 나라(소설가가 은유를 통해 묘사한 것처럼)를 창조하기만 하면 된다. 현실을 닮아야 한다는 어떤 제약이나 구속도 없다. 

## 03. 타입과 추상화
- 추상화
  - 어떤 양상, 세부사항, 구조를 좀 더 명확히 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
  - 복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다.
    - 첫 번째 차원은 구체적인 사물들 간의 공통점음 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
    - 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.
  - 모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는것이다.
- 진정한 의미에서 `추상화`란 현실에서 출발하되 불필요한 부분을 도려내가면서 사물의 놀라운 본질을 드러나게 하는 과정이라고 할 수 있다. 
- 추상화의 수준, 이익, 가치는 `목적`에 의존적이다. 

### 개념
- 공통점을 기반으로 객체들을 묶이 위한 그릇을 `개념(concept)`라고 한다.
  - `개념`을 이용하면 객체를 여러 그룹으로 `분류`할 수 있다.
  - 결국 각 `객체`는 특정한 `개념`을 포함하는 그룹의 일원으로 포함되며, 개념 그룹의 일원이 된 객체를 그 개념의 `인스턴스`라고 한다. 
- 개념의 세 가지 관점
  - 심볼
    - `심볼`이란 개념을 가리키는 이름이다. ex) 앨리스 이야기에서 `트럼프`라는 이름이 개념의 심볼
    - `내연`이란 개념의 의미를 타나낸다. 내연은 개념을 객체에게 적용할 수 있는지 여부를 판단하기 위한 조건이다. 
    - `외연`이란 개념에 속하는 객체들, 즉 개념의 인스턴스들이 모여 이뤄진 집합이다. 
### 객체를 분류하기 위한 틀
- `분류`는 객체지향의 가장 중요한 개념 중 하나다. 어떤 `객체`를 어떤 `개념`으로 분류할지가 객체지향의 품질을 결정한다. 
### 분류는 추상화를 위한 도구다.
- 개념을 통해 객체를 `분류`하는 과정은 추상화의 두 가지 차원을 모두 사용한다. 

### 타입
- 타입은 개념이다. 
- 타입의 정의는 개념의 정의와 완전히 동일하다. 타입은 공통점을 기반으로 객체들을 묶기 위한 틀이다. 타입은 개념과 마찬가지로 심볼, 내연, 외연을 이용해 서술할 수 있고, 타입에 속하는 객체 역시 타입의 인스턴스라고 한다. 
- 타입 시스템의 목적은 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것이다. 
- 타입은 데이터가 어떻게 사용되느냐에 관한 것이다.
- 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다. 
### 일반화/특수화 관계
- `일반적인 타입`은 `특수한 타입`보다 '외연의 크기는 더 크고' '행동의 수는 더 적다'.
- 앨리스 트럼프 비유
  - 일반적 타입(슈퍼타입)
    - 트럼프
      - 납작 엎드릴 수 있다.
      - 뒤집어질 수 있다.
  - 특수적 타입(서브타입)
    - 트럼프 인간
      - 납작 엎드릴 수 있다.
      - 뒤집어질 수 있다.
      - `걸을 수 있다.`
  - 슈퍼타입과 서브타입에서 중요한 것은 두 타입 간의 관계가 행동에 의해 결정된다.
  - 어떤 타입을 다른 타입의 서브타입이라고 말할 수 있으려면 다른 타입을 대체할 수 있어야 한다. 
- 일반화/특수화 관계 표기 방법
### 정적 모델
- 타입의 목적
  - 왜 타입을 사용해야 하는가? 타입을 사용하는 이유는 인간의 인지 능력으로는 '시간에 따라 동적으로 변하는 객체의 복잡성'을 극복하기가 너무 어렵기 때문이다.
  - 타입은 객체의 상태에 복잡성을 부과하는 시간이라는 요소를 제거함으로써 시간에 독립적인 정적인 모습으로 객체를 생각할 수 있게 해준다. 
- 이런 관점에서 결국 타입은 `추상화`다. 시간 요소와 상태 변화 요소를 제거하고, 철저하게 정적인 관점에서 객체의 모습을 묘사하게 해준다. 
- ex) 앨리스의 키=100cm, 키=80cm, 키=300cm 였던 것을 앨리스의 상태 `키`, 행동 `버섯을 먹다`, `음료를 마시다` `부채질하다`와 같은 타입화

- 객체를 분류하는 기준은 `타입`이며, `타입`을 나누는 기준은 객체가 수행하는 `행동`이다. 
- `클래스`는 단지 `타입`을 구현하기 위해 프로그래밍 언어에서 제공하는 구현 메커니즘일뿐이다. 

## 04. 역할, 책임, 협력
### 책임의 분류
- 객체의 책임은 `객체가 무엇을 알고 있는가(knowing)`과 `무엇을 할 수 있는가(doing)`으로 구성된다. 
- 하는 것(doing)
  - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작시키는 것
  - 다른 객체의 활동을 제어하고 조절하는 것
- 아는 것(knowing)
  - 개인적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
- 객체이 책임을 이야기할 때는 일반적으로 외부에서 접근 가능한 공용 서비스의 관점에서 이야기한다. 즉, 책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것의 측면)와 외부에 제공해 줄 수 있는 서비스(하는 것의 측면의) 목록이다. 따라서 책임은 객체의 `공용 인터페이스`를 구성한다.

### 역할이 답이다.
- 역할을 통해 단수화한 협력

### 객체지향 설계 기법
#### 1. 책임-주도 설계(RDD)
- RDD는 협력에 필요한 책임을들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 애플리케이션을 설계한다.
- 절차
  - 시스템이 사용자에게 제공해야 하는 기능인 `시스템 책임`을 파악한다.
  - 시스템 책임을 `더 작은 책임`으로 분할한다.
    - `분할된 책임`을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 `할당`한다.
  - 객체가 책임을 수행하는 중에 `다른 객체의 도움이 필요한 경우` 이를 책임질 `적절한 객체 또는 역할을 찾는다.`
    - 해당 객체 또는 역할에게 책임을 할당함으로써 `두 객체가 협력하게 한다.`

#### 2. 디자인 패턴
- 디자인 패턴은 전문가들이 반복적으로 사용하는 해결 방법을 정의해 놓은 설계 템플릿의 모음이다. 패턴은 전문가들이 특정 문제를 해결하기 위해 이미 식별해 놓은 역할, 책임, 협력의 모음이다. 패턴을 알고 있다면 바퀴를 반복적으로 발명할 필요가 없다. 필요로 하는 역할, 책임, 협력이 디자인 패턴 안에 이미 존재하기 때문이다.

#### 3. 테스트-주도 개발(RDD)
- 테스트 주도 개발은 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식을 따른다. TDD는 테스트가 아니라 설계를 위한 기법임을 기억하자. 즉, TDD의 핵심은 테스트 작성이 아니고, 테스트는 단지 TDD 개발을 통해 얻을 수 있는 별도의 보너스 같은 것이다. 실제 목적은 구체적인 코드를 작성해가면서 역할, 책임, 협력을 `식별`하고 식별된 역할, 책임, 협력이 적합한지를 `피드백`받는 것이다.
- TDD는 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각하라고 충고한다.
  - 그러나 이 같은 종류의 충고는 역할, 책임, 협력의 관점에서 객체를 바라보지 않을 경우 무의미하다. 
- TDD는 테스트를 작성하는 것이 아니라, 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드로 작성하는 것이다. 
- TDD는 RDD의 기본 개념을 따른다. 
- TDD는 객체지향에 대한 깊이 있는 지식을 요구한다. 
