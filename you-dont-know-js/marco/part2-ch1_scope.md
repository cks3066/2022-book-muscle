# 스코프란 무엇인가

- 변수는 어디에 살아있을까?, 프로그램은 필요할 때 변수를 어떻게 찾을까?
- 위와 같은 질문을 통해, `특정 장소에 변수를 저장하고 나중에 그 변수를 찾는 데`는 `잘 정의된 규칙이 필요`하다는 점을 알 수 있다.
  - 이러한 규칙을 `스코프(scope)`라 한다.

## 컴파일러 이론

- 자바스크립트는 사실 `컴파일러 언어`다.
  - 전통적인 컴파일러 언어의 처리 과정에서는 프로그램을 이루는 소스코드가 실행되기 전에 보통 3단계를 거친다. 이를 `컴파일레이션`이라 한다.
    - 1. 토크나이징(Tokenizing) / 렉싱(Lexing)
    - 2. 파싱(Parsing)
    - 3. 코드 생성(Code-Generation)

## 스코프 이해하기

- 자바스크립트의 작동과정을 이해하려면 각 주체의 입장에서 생각해야 한다.

  - 엔진 : `컴파일레션의 시작부터 끝까지` 전 과정과 자바스크립트 `프로그램 실행`을 책임진다.
  - 컴파일러 : 엔진의 친구로, `파싱과 코드 생성`의 모든 잡일을 도맡아 한다.
  - 스코프 ; 엔진의 또 다른 친구로, 선언된 모든 `확인자(변수) 검색 목록을 작성하고 유지`한다. 또한, 엄격한 규칙을 강제하여 `현재 실행 코드에서 확인자의 적용 방식`을 정한다.

- 엔진은 `var a = 2;`를 두 개의 서로 다른 구문으로 본다.

  - 하나는 `컴파일러`가 컴파일레이션 과정에서 처리할 구문이고, 다른 하나는 실행 과정에서 `엔진`이 처리할 구문이다.
  - 컴파일러는 렉싱을 통해 구문을 토큰으로 쪼갠다. 그 후 토큰을 파싱해 트리 구조로 만든다.
  - 1. `컴파일러`가 'var a'를 만나면 `스코프`에게 변수 a가 특정한 스코프 컬렉션 안에 있는지 묻는다. 변수 a가 이미 있다면 컴파일러는 선언을 무시하고 지나가고, 그렇지 않으면 컴파일러는 새 변수 a를 스코프 컬렉션 내에 선언하라고 요청한다.
    - 즉, 컴파일러가 변수를 선언한다(현재 스코프에 미리 변수가 선언되어 있지 않은 경우)
  - 2. 그 후 `컴파일러`는 'a = 2' 대입문을 처리하기 위해 나중에 엔진이 실행할 수 있는 코드를 생성한다. `엔진`은 코드 실행 전, `스코프`에게 변수 a가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인한다. 가능하다면 엔진은 변수 a를 사용하고 아니라면 엔진은 다른 곳을 살핀다.
    - 즉, 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대입한다.

- 컴파일러 관련 용어
  - LHS 검색
    - Left-Hand Side, 대입 연산의 방향이 왼쪽을 향할 때를 의미한다.
    - 변수가 대입 연산자의 왼쪽에 있을 때 수행한다.` var a = 2`
      - 값 2를 인자a에 대입하는 연산이므로 LHS 검색이다.
  - RHS 검색
    - Right-Hand Side, 대입 연산의 방향이 오른쪽을 향할 때를 의미한다(RHS는 정확히 말하면 `왼편이 아닌 쪽`에 가깝다).
    - 특정 변수의 값을 찾는 것이다. `console.log(a)`
      - 구조문에서 a에 아무것도 대입하지 않고 a의 값을 찾아서 가져오므로 RHS 검색이다.

```jsx
function foo(a) {
  var b = a;
  // 3. [RHS] 변수 a의 값을 찾아서 가져오는 RHS 검색을 수행한다.
  // 4. [LHS] 변수 a의 값을 변수 b에 대입 시 LHS 검색을 수행한다.
  return a + b;
  // 5. [RHS] 변수 a의 값을 찾아서 가져오는 RHS 검색을 수행한다.
  // 6. [RHS] 변수 b의 값을 찾아서 가져오는 RHS 검색을 수행한다.
}

var c = foo(2);
// 1. [RHS] foo()함수 호출 시 RHS 검색을 수행한다.
// 2. [LHS] 값 2를 foo()에 넘겨줄 때(a에 암시적 인자 대입이기도 하다) LHS 검색을 수행한다.
// 7. [LHS] foo(2)에서 반환된 값을 변수 c에 대입할 때 LHS 검색을 수행한다.
```

## 중첩 스코프

- 스코프는 `확인자 이름으로 변수를 찾기` 위한 `규칙의 집합`이다.
  - 블록이나 함수가 중첩되면 스코프도 중첩된다.
  - 대상 변수를 현재 스코프에서 찾지 못하면 엔진은 `다음 바깥의 스코프`로 넘어가는 식으로 변수를 찾거나, `글로벌 스코프`라 부르는 가장 바깥 스코프에 도달할 때까지 계속한다.

```jsx
// 대상 변수를 현재 스코프에서 찾지 못하면 엔진은 `다음 바깥의 스코프`로 넘어가는 식으로 변수를 찾는다.
function foo(a) {
  const b = 2;
  function bar(a) {
    console.log("a", a, "b", b);
  }
  bar(a);
}
const b = 3;
foo(1); // a 1 b 2
```

```jsx
// 다음 바깥의 스코프에도 찾는 변수가 없으면, `글로벌 스코프`라 부르는 가장 바깥 스코프에 도달할 때까지 계속한다.
function foo(a) {
  function bar(a) {
    console.log("a", a, "b", b);
  }
  bar(a);
}
const b = 3;
foo(1); // a 1 b 3
```

- 중첩 스코프 탐색시 규칙
  - 엔진은 현재 스코프에서 변수를 찾기 시작하고 찾지 못하면 한 단계씩 올라간다.
  - 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색을 멈춘다.

## 오류

- LHS와 RHS를 구분하는 이유는, 이 두 검색 방식은 변수가 아직 선언되지 않았을 때(=검색한 모든 스코프에서 찾지 못했을 때) 서로 다르게 동작하기 때문이다.
- ReferenceError는 스코프에서 `RHS 검색 시` 대상을 찾지 못하면 발생하는 에러 타입이다.
  - Strict mode일 때, 글로벌 변수를 자동 또는 암시적으로 생성할 수 없으므로, `LHS 검색`을 하다가 글로벌 스코프에서도 변수를 찾지 못하면 엔진은 ReferenceError를 발생시킨다.
    - (normal mode였다면 글로벌 스코프는 엔진이 검색하는 이름을 가진 새 변수를 생성해서 엔진에게 넘겨줘서 에러가 발생하지 않는다)
- TypeError는 스코프 검색은 성공했으나 결괏값을 가지고 적합하지 않거나 불가능한 시도를 한 경우를 의미한다.
  - 함수가 아닌 값을 함수처럼 실행하거나 null이나 undefined 값을 참조할 때 발생하는 에러다.
