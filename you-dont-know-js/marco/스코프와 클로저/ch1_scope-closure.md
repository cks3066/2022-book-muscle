# 스코프란 무엇인가

- 변수는 어디에 살아있을까?, 프로그램은 필요할 때 변수를 어떻게 찾을까?
- 위와 같은 질문을 통해, `특정 장소에 변수를 저장하고 나중에 그 변수를 찾는 데`는 `잘 정의된 규칙이 필요`하다는 점을 알 수 있다.
  - 이러한 규칙을 `스코프(scope)`라 한다.

## 컴파일러 이론

- 자바스크립트는 사실 `컴파일러 언어`다.
  - 전통적인 컴파일러 언어의 처리 과정에서는 프로그램을 이루는 소스코드가 실행되기 전에 보통 3단계를 거친다. 이를 `컴파일레이션`이라 한다.
    - 1. 토크나이징(Tokenizing) / 렉싱(Lexing)
    - 2. 파싱(Parsing)
    - 3. 코드 생성(Code-Generation)

## 스코프 이해하기

- 자바스크립트의 작동과정을 이해하려면 각 주체의 입장에서 생각해야 한다.

  - 엔진 : `컴파일레션의 시작부터 끝까지` 전 과정과 자바스크립트 `프로그램 실행`을 책임진다.
  - 컴파일러 : 엔진의 친구로, `파싱과 코드 생성`의 모든 잡일을 도맡아 한다.
  - 스코프 ; 엔진의 또 다른 친구로, 선언된 모든 `확인자(변수) 검색 목록을 작성하고 유지`한다. 또한, 엄격한 규칙을 강제하여 `현재 실행 코드에서 확인자의 적용 방식`을 정한다.

- 엔진은 `var a = 2;`를 두 개의 서로 다른 구문으로 본다.

  - 하나는 `컴파일러`가 컴파일레이션 과정에서 처리할 구문이고, 다른 하나는 실행 과정에서 `엔진`이 처리할 구문이다.
  - 컴파일러는 렉싱을 통해 구문을 토큰으로 쪼갠다. 그 후 토큰을 파싱해 트리 구조로 만든다.
  - 1. `컴파일러`가 'var a'를 만나면 `스코프`에게 변수 a가 특정한 스코프 컬렉션 안에 있는지 묻는다. 변수 a가 이미 있다면 컴파일러는 선언을 무시하고 지나가고, 그렇지 않으면 컴파일러는 새 변수 a를 스코프 컬렉션 내에 선언하라고 요청한다.
    - 즉, 컴파일러가 변수를 선언한다(현재 스코프에 미리 변수가 선언되어 있지 않은 경우)
  - 2. 그 후 `컴파일러`는 'a = 2' 대입문을 처리하기 위해 나중에 엔진이 실행할 수 있는 코드를 생성한다. `엔진`은 코드 실행 전, `스코프`에게 변수 a가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인한다. 가능하다면 엔진은 변수 a를 사용하고 아니라면 엔진은 다른 곳을 살핀다.
    - 즉, 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대입한다.

- 컴파일러 관련 용어
  - LHS 검색
    - Left-Hand Side, 대입 연산의 방향이 왼쪽을 향할 때를 의미한다.
    - 변수가 대입 연산자의 왼쪽에 있을 때 수행한다.` var a = 2`
      - 값 2를 인자a에 대입하는 연산이므로 LHS 검색이다.
  - RHS 검색
    - Right-Hand Side, 대입 연산의 방향이 오른쪽을 향할 때를 의미한다(RHS는 정확히 말하면 `왼편이 아닌 쪽`에 가깝다).
    - 특정 변수의 값을 찾는 것이다. `console.log(a)`
      - 구조문에서 a에 아무것도 대입하지 않고 a의 값을 찾아서 가져오므로 RHS 검색이다.

```jsx
function foo(a) {
  var b = a;
  // 3. [RHS] 변수 a의 값을 찾아서 가져오는 RHS 검색을 수행한다.
  // 4. [LHS] 변수 a의 값을 변수 b에 대입 시 LHS 검색을 수행한다.
  return a + b;
  // 5. [RHS] 변수 a의 값을 찾아서 가져오는 RHS 검색을 수행한다.
  // 6. [RHS] 변수 b의 값을 찾아서 가져오는 RHS 검색을 수행한다.
}

var c = foo(2);
// 1. [RHS] foo()함수 호출 시 RHS 검색을 수행한다.
// 2. [LHS] 값 2를 foo()에 넘겨줄 때(a에 암시적 인자 대입이기도 하다) LHS 검색을 수행한다.
// 7. [LHS] foo(2)에서 반환된 값을 변수 c에 대입할 때 LHS 검색을 수행한다.
```

## 중첩 스코프

- 스코프는 `확인자 이름으로 변수를 찾기` 위한 `규칙의 집합`이다.
  - 블록이나 함수가 중첩되면 스코프도 중첩된다.
  - 대상 변수를 현재 스코프에서 찾지 못하면 엔진은 `다음 바깥의 스코프`로 넘어가는 식으로 변수를 찾거나, `글로벌 스코프`라 부르는 가장 바깥 스코프에 도달할 때까지 계속한다.

```jsx
// 대상 변수를 현재 스코프에서 찾지 못하면 엔진은 `다음 바깥의 스코프`로 넘어가는 식으로 변수를 찾는다.
function foo(a) {
  const b = 2;
  function bar(a) {
    console.log("a", a, "b", b);
  }
  bar(a);
}
const b = 3;
foo(1); // a 1 b 2
```

```jsx
// 다음 바깥의 스코프에도 찾는 변수가 없으면, `글로벌 스코프`라 부르는 가장 바깥 스코프에 도달할 때까지 계속한다.
function foo(a) {
  function bar(a) {
    console.log("a", a, "b", b);
  }
  bar(a);
}
const b = 3;
foo(1); // a 1 b 3
```

- 중첩 스코프 탐색시 규칙
  - 엔진은 현재 스코프에서 변수를 찾기 시작하고 찾지 못하면 한 단계씩 올라간다.
  - 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색을 멈춘다.

## 오류

- LHS와 RHS를 구분하는 이유는, 이 두 검색 방식은 변수가 아직 선언되지 않았을 때(=검색한 모든 스코프에서 찾지 못했을 때) 서로 다르게 동작하기 때문이다.
- ReferenceError는 스코프에서 `RHS 검색 시` 대상을 찾지 못하면 발생하는 에러 타입이다.
  - Strict mode일 때, 글로벌 변수를 자동 또는 암시적으로 생성할 수 없으므로, `LHS 검색`을 하다가 글로벌 스코프에서도 변수를 찾지 못하면 엔진은 ReferenceError를 발생시킨다.
    - (normal mode였다면 글로벌 스코프는 엔진이 검색하는 이름을 가진 새 변수를 생성해서 엔진에게 넘겨줘서 에러가 발생하지 않는다)
- TypeError는 스코프 검색은 성공했으나 결괏값을 가지고 적합하지 않거나 불가능한 시도를 한 경우를 의미한다.
  - 함수가 아닌 값을 함수처럼 실행하거나 null이나 undefined 값을 참조할 때 발생하는 에러다.

## 렉시컬 스코프

- 렉시컬 스코프란 개발자가 코드를 작성할 때 함수를 어디에 선언하는지에 따라 정의되는 스코프를 말한다.
- 컴파일레이션의 렉싱 단계에서는 모든 확인자가 어디서 어떻게 선언됐는지 파악하여 실행 단계에서 어떻게 확인자를 검색할지 예상할 수 있도록 도와준다
- 즉, 자바스크립트 엔진이 코드를 인터프리팅하기 전에 컴파일한다. 컴파일레이션 단계 중에는 모든 선언문을 찾아 적절한 스코프에 연결해주는 과정이 렉시컬 스코프의 핵심이다.

## 함수 스코프 vs 블록 스코프

- "var a = 2;"는 하나의 구문처럼 보이지만, 자바스크립트 엔진은 그렇게 보지 않는다. 엔진은 이를 "var a"(`선언문`)와 "a = 2"(`대입문`)라는 독립된 구문으로 보고, 첫째 구문은 `컴파일러 단계`에서 처리하고 둘째 구문은 `실행 단계`에서 처리한다.
- 스코프의 모든 선언문은 어디서 나타나든 실행 전에 먼저 처리된다. 이 과정은 `호이스팅`이라 하며, (변수와 함수) 선언문 각각이 속한 스코프의 꼭대기로 `끌어올려`지는 작업이다. 그 과정에서 `선언문` 자체는 끌어올려지지만, 함수 표현식의 대입문을 포함한 모든 `대입문`은 끌어올려 지지 않는다.

## 스코프 클로저

- 클로저는 렉시컬 스코프에 의존해 코드를 작성한 결과로 `그냥` 발생한다.
  - 이용하려고 굳이 의도적으로 클로저를 생성할 필요도 없다.
  - 모든 코드에서 클로저는 생성되고 사용된다.
  - 따라서 클로저를 목적에 따라 확인하고, 받아들이고, 이용할 뿐이다.
- 클로저는 `함수가 속한 렉시컬 스코프`를 기억하여 함수가 `렉시컬 스코프 밖에서` 실행될 때에도 이 스코프에 `접근`할 수 있게 하는 기능을 뜻한다.

```jsx
function foo() {
  const a = 2;
  function bar() {
    // bar()함수는 foo()의 렉시컬 스코프에 접근할 수 있다.
    console.log(a);
  }
  return bar; // bar()함수 자체를 값으로 반환한다.
}

const baz = foo(); // foo()를 실행하여 반환된 값(bar()함수)을 baz 변수에 대입

baz(); // baz()함수 호출 -> 대입되어 있는 bar()함수가 호출된다.

// 이 경우 함수 bar()는 함수가 선언된 렉시컬 스코프 밖에서 실행됐다.
```

- 일반적으로 foo()가 실행된 후에는 foo()의 내부 스코프가 사라졌다고 생각할 것이다.
  - 이것은 엔진이 가비지 콜렉터를 고용해 더는 사용하지 않는 메모리를 해제시킨다는 사실을 알기 때문이다.
- 그러나 실제로는 foo() 실행 이후에도, foo의 내부 스코프는 여전히 bar()에 의해 `사용 중`이므로 `해제되지 않는다`.
  - 선언된 위치 덕에 bar()는 foo() 스코프에 대한 렉시컬 스코프 클로저를 가지고, foo()는 bar()가 나중에 참조할 수 있도록 스코프를 살려둔다.
    - 즉, bar()는 여전히 foo()라는 렉시컬 스코프에 대한 참조를 가지는데, 그 `참조`를 `클로저`라고 한다.
- 클로저는 호출된 함수가 원래 선언된 렉시컬 스코프에 계속해서 접근할 수 있도록 허용한다.
  - 즉, 어떤 방식이든 `함수를 값으로 넘겨` `다른 위치에서 호출`하는 행위는 모두 클로저가 작용한 예다.
  - 어떤 방식으로 내부 함수를 자신이 속한 렉시컬 스코프 밖으로 수송하든 함수는 처음 선언된 곳의 스코프에 대한 참조를 유지한다.

### 반복문과 클로저

```jsx
for (var i = 1; i <= 5; i++) {
  // var 임을 주의
  setTimeout(function timer() {
    console.log(i); // 6 6 6 6 6
  }, i * 1000);
}
```

위 코드는, 반복문 안 총 5개의 함수들은 반복마다 따로 정의됐음에도 모두 같은 글로벌 스코프 클로저를 공유하게 되어, 해당 스코프 안에는 오직 하나의 i(=6)만이존재한다. 따라서 모든 함수는 같은 i에 대한 참조를 공유한다.

이를 해결하기 위해, 반복마다 i의 값을 저장할 변수를 IIFE 안에 선언하고 할당한다.
즉, 필요한 것은 반복 별 블록 스코프다.

```jsx
for (var i = 1; i <= 5; i++) {
  (function () {
    var j = i;
    setTimeout(function timer() {
      console.log(j); // 1, 2, 3, 4, 5
    }, j * 1000);
  })();
}
```

- 블록 스코프를 다시 보자
  - 아래 코드에서 let 선언문을 for 문 내부에 사용해보자. 그러면, let 선언 변수는 한 번만 선언되는 것이 아니라 `반복할 때마다` 선언된다. 따라서 해당 변수는 반복마다 이전 반복이 끝난 이후의 값으로 초기화된다.
  - 즉, 블록 스코프와 클로저를 함께 활용하여 문제를 해결할 수 있다.

```jsx
for (let i = 1; i <= 5; i++) {
  // let으로 변경됨
  setTimeout(function timer() {
    console.log(i); // 1 2 3 4 5
  }, i * 1000);
}
```

### 스코프와 렉시컬 this

- 렉시컬 스코프는 작성할 때, 동적 스코프(그리고 this!)는 런타임에 결정된다.
- 렉시컬 스코프는 어디서 함수가 선언됐는지와 관련 있지만, 동적 스코프는 어디서 함수가 호출됐는지와 관련있다.

```js
function foo() {
  console.log(a);
}

function bar() {
  var a = 3;
  foo();
}

var a = 2;
bar(); // 2
```

- 화살표 함수는 this 바인딩과 연계될 때는 일반 함수처럼 작동하지 않는다.
  - 화살표 함수는 모든 this 바인딩에 대한 일반 규칙을 폐기하고, 대신 자신 가까이의 둘러싼 렉시컬 스코프에서 this 값을 받아온다.
