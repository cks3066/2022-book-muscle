# 비동기성: 지금과 나중

- 프로그램에서 '지금'에 해당하는 부분 그리고 '나중'에 해당하는 부분 사이의 관계가 바로 `비동기 프로그램`의 핵심이다.

## 1.1 프로그램 덩이

- 자바스크립트 포로그램은 .js 파일 하나로도 작성할 수 있지만 보통은 여러 개의 `덩이`,

  - 즉, `지금 실행 중인 프로그램 덩이 하나`와 `나중에 실행할 프로그램 덩이들`로 구성된다. (가장 일반적인 프로그램 덩위 단위는 함수다)

- `나중`은 `지금`의 직후가 아니다!!!
  - `지금` 당장 끝낼 수 없는 작업은 비동기적으로 처리되므로 프로그램을 중단(blocking)하지 않는다.
- AJAX는 비동기적으로 `지금` 요청하고 `나중`에 결과를 받는다.
  - `지금`부터 `나중`까지 `기다리는` 가장 간단한 방법은 `콜백 함수`를 이용하는 것이다.

```js
const data = ajax("http://some.url.1");
console.log(data); // 동기적인 방식인, 이 라인에서 ajax의 결과값을 받지 못한다.
```

```js
// ajax의 비동기 작동의 값을 콜백함수를 이용하여 수신
ajax("http://some.url.1", function myCallbackFunction(data) {
  console.log(data); // data 값 수신 완료
}
```

## 1.2 이벤트 루프

- "최근까지(ES6 도입 전까지) 사실 자바스크립트에 비동기 개념은 없었다."
  - 자바스크립트 엔진은 `요청받으면` 프로그램을 주어진 시점에 한 덩이씩 묵묵히 실행할 뿐이다.
    - 비동기 개념을 이해하려면, 여기서 `누가 "요청"`을 하는지가 중요하다.
  - ES6부터는 이벤트 루프와 태스크 큐 관리 방식의 관할이 호스팅 환경이 아니라 자바스크립트 엔진으로 변경되었다.(이벤트 루프 큐의 스케줄링을 직접 세밀하게 제어해야 하는 `프라미스` 도입을 계기로 바뀌었다)
- 누가 자바스크립트 엔진에게 `요청`을 하는가
  - 자바스크립트 엔진은 혼자서는 안 되고 반드시 `호스팅 환경`(웹브라우저, Node.js 서버 등)에서 실행된다.
    - 환경은 달라도 자바스크립트 엔진의 `싱글스레드(Thread)`는 공통이다.
    - 여러 프로그램 덩이를 시간에 따라 매 순간 한 번씩 엔진을 실행시키 것은 호스팅(웹브라우저 등)의 `이벤트 루프`라는 장치다.
- 다시 말해, `자바스크립트 엔진`은 애당초 시간이란 개념 따윈 없었고, 이벤트 루프에서 시시각각 주는 자바스크립트 코드 조각을 `그냥 받아서 처리하는 실행기`일 뿐이다. `이벤트`를 스케줄링하는 일은 언제나 엔진을 감싸고 있던 주위 `환경`의 몫이다.

- 이벤트 루프를 의사 코드로 단순화하여 구현해본다면 다음과 같을 수 있다.
  - 코드에 while 무한 루프가 있는데, 이 루프의 매 순회(iteration)를 `틱(Tick)`이라고 한다.
    - `틱`이 발생할 때마다 `큐`에 적재된 `이벤트(콜백함수)`를 꺼내어 실행한다.
  - setTimeout()은 `환경(web api)`에 콜백함수에 대한 타이머를 실행한다.
  - 타이머의 시간이 끝나면, `환경(web api)`은 콜백을 `태스크 큐`에 삽입한다.
  - 이벤트 루프는 `콜 스택`과 `태스크 큐`를 주시하다가, `콜 스택`이 비어있으면, `태스크 큐`의 첫번째 콜백을 스택에 쌓는다.

```js
// 'eventLoop'는 큐(선입 선출) 역할을 하는 배열이다
const eventLoop = [];
const event;

// "무한" 실행
while(true) {
  // "틱" 발생
  if (eventLoop.length > 0) {
    // 큐에 있는 다음 이벤트 조회
    event = eventLoop.shift();
    // 이제 다음 이벤트를 실행
    try {
      event();
    } catch (error) {
      reportError(error)
    }
  }
}
```

## 1.3 병렬 스레딩

- `비동기(async)`와 `병렬(Parallel)`은 서로 의미가 다르다.
  - 병렬은 `동시`에 일어나는 일들과 연관된다.
    - 여러 스레드는 하나의 프로세스 메모리를 공유한다.
    - 이 때문에 인터럽션/인터리빙 같은 요소가 발생하고 스레드 프로그래밍이 어렵다.
  - 비동기는 `지금`과 `나중` 사이의 간극에 대한 용어다.
    - 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유 메모리에 병렬로 접근하거나 변경할 수 없다.
      - 병렬성과 직렬성이 나뉜 스레드에서 이벤트 루프를 협동하는 형태로 공존하는 모습이다.
- 자바스크립트는 절대로 스레드 간에 데이터를 공유하는 법이 없으므로 결정적인 편이다(자바스크립트의 `비결정성의 수준`은 문제가 되지 않는다).

  - 하지만 그렇다고 자바스크립트 프로그램이 항상 결정적인 것도 아니다.(예시: 아래 코드)

- 아래 코드에서 자바스크립트는 싱글스레드로 작동하니까, foo()->bar() 순서로 실행되면 결과값은 42지만, 반대로 bar()->foo() 순서면 41이 된다.

```js
let a = 20;

function foo() {
  a = a + 1;
}

function bar() {
  a = a * 2;
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수로 가정
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

- 똑같은 코드인데 결과값은 두 가지이므로 이 프로그램은 비결정적이다. 그러나 여기서 비결정성은 함수(이벤트)의 순서에 따른 것이지, 스레드처럼 문의 순서(표현식의 처리 순서) 수준까지는 아니다. 즉, 스레드보다는 결정적이라고 할 수 있다.
- 자바스크립트에서는 함수 순서에 따른 비결정성을 경합 조건(race condition)이라고 표현한다. foo()와 bar() 중 누가 먼저 실행되나 내기하는 경합 같다는 의미에서다.

## 1.4 동시성(Concurrency)

- 사용자가 스크롤바를 아래로 내리면 계속 갱신된 상태 리스타가 화면에 표시되는 웹 페이지를 만들려고 하면, (적어도) 2개의 분리된 "프로세스"(논리적으로 연결된 순차적인 일련의 작업을 나타내는 가상 작업)를 동시에 실행할 수 있어야 제대로 기능을 구현할 수 있다.
  - 1. 첫 번째 프로세스는, 사용자가 페이지를 스크롤바로 내리는 순간 발생하는 onscroll 이벤트에 반응한다.
  - 2. 두 번째 프로세스는, AJAX 응답을 받는다.(그리고 페이지에 데이터를 표시한다)
- 그런데 성미 급한 사용자가 아주 빨리 스크롤바를 내리면 처음 수신된 응답을 처리하는 도중 2개 이상의 onscroll 이벤트가 발생하기에 십상이고 onscroll 이벤트와 AJAX 요청 이벤트가 아주 빠르게 발생하며 `인터리빙` 된다.
  - 이처럼 `동시성`은 복수의 "프로세스"가 같은 시간 동안 동시에 실행됨을 의미한다.
    - 동시성은 각 프로세스 작업들이 `처리 수준 병행성(개별 프로세서의 스레드)`로 처리되는지와 관계없다.
    - 동시성은 처리 수준 병행성(개별 프로세서의 스레드)과 상반되는 개념의 `"프로세스" 수준(작업 수준)의 병행성`이라고 할 수 있다.

### 1.4.1 비상호 작용(Noninteracting)

- 어떤 프로그램 내에서 복수의 "프로세스"가 단계/이벤트를 동시에 인터리빙할 때 이들 프로세스 사이에 연관된 작업이 없다면 프로세스 간 상호 작용은 사실 의미가 없다. 프로세스 간 상호 작용이 일어나지 않는다면, 비결정성은 완벽하게 수용 가능하다.
- 아래 코드 예제에서 2개의 동시 "프로세스" foo()와 bar()는 서로에게 영향을 미치지 않고 개별 작동하므로 실행 순서는 문제 삼을 필요 없다. 즉, 순서에 상관없이 언제나 정확히 작동하므로 경합 조건에 다른 버그가 아니다.

```js
const res = {};

function foo(results) {
  res.foo = results;
}

function bar(results) {
  res.bar = results;
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수로 가정
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

### 1.4.2 상호 작용(Interaction)

- 동시 프로세스들은 필요할 때 스코프나 DOM을 통해 간접적으로 상호 작용한다. 이대 경합 조건이 발생하지 않도록 잘 조율해줘야 한다.

- 경합 조건을 해결하기 위해, 상호 작용의 순서를 조정(조건문 분기)한 예제

```js
const res = [];

function response(data) {
  if (data.url == "http://some.url.1") {
    res[0] = data;
  } else if (data.url == "http://some.url.2") {
    res[1] = data;
  }
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수로 가정
ajax("http://some.url.1", response);
ajax("http://some.url.2", response);
```

- 한꺼번에 여러 함수를 호출하는 형태로 공유 DOM을 통해 상호 작용하는 경우도, `if(a&&b)`과 같은 조건으로 `baz()` 호출에 대한 관문을 설정한다. a와 b중 누가 일찍 도착할지 알 수는 없지만 관문은 반드시 둘 다 도착한 다음에야 열린다.

```js
let a, b;

function foo(x) {
  a = x * 2;
  if (a && b) {
    baz();
  }
}

function bar(y) {
  b = y * 2;
  if (a && b) {
    baz();
  }
}

function baz() {
  console.log(a + b);
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수로 가정
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

- '선착순 한 명만 이기는' 형태를 걸쇠(Latch)라 한다. 비결정성을 수용하는 조건으로 결승선을 통과한 오직 한 명의 승자만 뽑는 '달리기 시합'을 명시적으로 선언한다.
  - foo와 bar 둘 중 먼저 실행된 함수가 if(!a) 조건을 통과하고 그 다음으로 호출된 함수는 무시한다.(2등에겐 상이 없다 ㅠㅠ)

```js
let a;

function foo(x) {
  if (!a) {
    a = x * 2;
    baz();
  }
}

function bar(x) {
  if (!a) {
    a = x / 2;
    baz();
  }
}

function baz() {
  console.log(a);
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수로 가정
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

### 1.4.3 협동(Cooperation)

- `협동적 동시성(Cooperative Concurrency)` 역시 동시성을 조정하는 다른 방안으로, 스코프에서 값을 공유하는 식의 상호 작용엔 별 관심이 없다.

  - 협동적 동시성은 실행 시간이 오래 걸리는 "프로세스"를 여러 단계/배치로 쪼개어 다른 동시 "프로세스"가 각자 작업을 이벤트 루프 큐에 인터리빙하도록 하는 게 목표다.

- 아래 예제 코드에서 `if (data.length > 0)`으로 남은 데이터에 대한 setTimeout 처리를 하지 않았다면, 수 천만개의 데이터를 처리하는 "프로세스" 실행 중에 페이지가 그대로 멈춰서 함수 실행 및 UI 업데이트, 이벤트(스크롤링, 타이핑, 버튼 클릭 등)가 모두 먹통이 되는 문제가 생길 것이다.
  - 빠르게 처리할 수 있는 단위라고 가정한 1,000개 원소 단위로 데이터 집합을 처리했다.
    - 이렇게 하면 더 만은 후속 프로세스를 처리해야 하지만, 각 프로세스 처리 시간은 단축되므로 이벤트 루프 큐에 `인터리빙`이 가능하고 `응답성`이 좋은 사이트를 만들 수 있다.
  - 여기서 `setTimeout(..., 0)`은 `비동기 스케줄링 꼼수(hack)` 중 하나로, "이 함수를 현재 이벤트 루프 큐의 맨 뒤에 붙여주시오"라는 뜻이다.
    - 엄밀히 말해, `setTimeout(..., 0)`은 원소를 이벤트 루프 큐에 곧바로 삽입하는 게 아니라 타이머가 다음 기회에 이벤트를 삽입하도록 작동한다. 예컨대, 연속 두 번 `setTimeout(..., 0)`을 호출해도 그 순서대로 처리되리란 보장이 없다. 따라서 이벤트 순서를 예측할 수 없는 타이머 표류 등 문제 상황이 발생할 수도 있다. 모든 환경에서 비동기 이벤트 순서를 고정할 직접적인 방법은(아직 없고) 다음 절에서 더 살펴본다고 한다~.

```js
var res = [];

// `response(..)`는 AJAX 호출 결과로 배열을 받는다.
function response(data) {
  // 한번에 1,000개씩 실행하자
  var chunk = data.splice(0, 1000);

  // 기존 'res' 배열에 추가한다.
  res = res.concat(
    // 'chunk'값에 2를 곱하여
    // 배열의 원소를 하나씩 변환한다.
    chunk.map(function (val) {
      return val * 2;
    })
  );

  // 아직도 처리할 프로세스가 남아 있나?
  if (data.length > 0) {
    // 다음 배치를 비동기 스케줄링한다.
    setTimeout(function () {
      response(data);
    }, 0);
  }
}

// ajax()는 라이브러리에 있는 임의의 AJAX 함수로 가정
ajax("http://some.url.1", response);
ajax("http://some.url.2", response);
```

## 1.5 잡(Jobs)

- `잡 큐(Job Queue)`는 ES6부터 이벤트 루프 큐에 새롭게 도입된 개념이다.
  - 비유하자면, `이벤트 루프 큐`는 테마파크에서 롤러코스터를 타고나서 한 번 더 타고 싶어 다시 대기열 맨 끝에서 기다리는 것이고
  - `잡 큐`는 롤러코스터에서 내린 직후 대기열 맨 앞에서 곧바로 다시 타는 것이다.

## 1.6 문 순서(Statement Ordering)

- 자바스크립트 엔진은 코드를 컴파일한 뒤, 문 순서를 재정렬(최종 결과가 변경되지 않도록 안전하게 최적화) 하면서 실행 시간을 줄일 여지는 없는지 확인한다.(이런 과정은 육안으로 확인할 수 없다)
- 그러나 안전하지 않아 최적화(재정렬)하면 안 되는 경우도 있다.
  - 부수 효과가 있는 함수 호출(특히 getter 함수), ES6 프록시 객체 등은 컴파일러의 순서 조정으로 인해 현저한 부수 효과가 발생할 수 있다. 따라서 이런 경우는 순서 조정을 하면 안된다.

```js
function foo() {
  console.log(b);
  return 1;
}

var a, b, c;

// ES5.1 getter literal syntax
c = {
  get bar() {
    console.log(a);
    return 1;
  },
};

a = 10;
b = 30;

a += foo(); // 콘솔 30
// foo()호출로 인해 a=11이 됐다.(b는 여전히 30이어서 콘솔에 30이 직힌다)
b += c.bar; // 콘솔 11, b=31
// bar호출하여 콘솔에 a의 값인 11이 찍히고, b느 bar의 반환값인 1을 30에 더해 31이 된다.

console.log(a, b); // 콘솔 11, 31
```
