<aside>
💡 변수는 할당된 메모리 주소를 가리키고, 그 주소에 가면 해당 변수의 값이 있다. (원시 값 할당이라 친다) 변수가 재할당 되면, 새로운 메모리 공간을 만들고 그곳에 값을 할당한다. 변수는 가리키는 메모리 주소를 새로 만들어진 주소로 바꾸어 가리킨다. 그렇다면 여기서, 변수가 어느 주소를 가리키고 있어야 하는지에 대한 정보는 어디에 저장돼 있을까? 메모리 주소의 주솟값이 불변이라 뒤집어 씌워지지 않는다면, 가리켜야 하는 주소가 바뀌었을 때, 가지고 있던 주소를 새로운 주소로 어떻게 바꾸지????? 혹시 주소는 불변이 아니라 뒤집어 씌울 수 있는 건가?

///메모리 주소는 덮어씌워진다고 한다.

</aside>

1. **원시 타입의 값, 즉 원시 값(primitive type)은 변경 불가능한 값이다.**

   1. 변수와 값은 구분해서 생각해야 한다.
      1. 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체
      2. 값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과
   2. 변경 불가능하다는 것은 변수가 아니라 값을 말하는 것 이다.
   3. 즉 “원시 값은 변경 불가능하다”는 말은 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것이 아니다.
   4. 이러한 원시 값의 특성은 데이터의 신뢰성을 보장한다.

   ```jsx
   var str = 'hello';
   str[0] = 'H';
   console.log(str); // hello가 나온다. hello라는 문자열 원시 값을 수정할 수 없기 때문이다
   ```

   <aside>
   💡 왜 원시 값(primitive type)은 변경이 불가능 하다는 것인지 이해하지 못해 기록해뒀다. 원시 값을 값 자체가 아닌 변수로 착각했다. 상수라는 말 때문에 더 헷갈렸다. 상수는 재할당이 금지된 변수일 뿐이다. 마지막 데이터의 신뢰성을 보장한다는 말은 여전히 이해하지 못했다. 아마 저수준에서 그렇다는 소리인가?

   </aside>

2. **원시 값이 변경 불가능한 값이기 때문에 변수 값 재할당 시 새로운 메모리 공간을 확보하고 그곳에 새로 값을 할당하는 것이다. 그렇지 않았다면 값을 그냥 덮어 씌웠으면 됐다.**

   1. 만약 값을 변경할 수 있다면 예기치 않게 값이 변경될 수도 있다.
   2. 이는 상태 변경을 추적하기 어렵게 만든다.

   <aside>
   💡 왜 변수 재할당 시 새롭게 메모리 공간을 만들고 거기에 할당하는지 몰랐었다.

   </aside>

3. **변수에 원시 값을 갖는 변수를 할당하면 할당 받는 변수에는 할당 되는 변수의 원시 값이 복사되어 전달된다.**

   ```jsx
   let score = 80;
   let copy = score;
   console.log(score); //80
   console.log(copy); //80
   score = 100;
   console.log(score); //100
   console.log(copy); //80
   ```

   <aside>
   💡 값이 바뀔 줄 알았다. 이 챕터를 읽으며 원시 값과 메모리 공간에 대한 내 이해가 얼마나 부족했는지 알게 됐다. 참말로 부끄럽다.

   </aside>

4. **객체는 크기가 일정하지 않고, 프로퍼티 값이 객체일 수 있고, 복사해서 생성하는 비용이 많이 든다. 이러한 이유로 메모리를 효율적으로 사용하기 위해, 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계돼 있다.**

   <aside>
   💡 왜 객체는 변경가능한 값으로 설정했는지 궁금했는데 알게 됐다. 혹시 변수의 메모리 주소도 객체 처럼 변경 가능한 값인게 아닐까?

   </aside>
