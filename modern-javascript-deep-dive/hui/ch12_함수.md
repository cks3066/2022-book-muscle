### 함수란?

---

수학의 **함수는 입력을 받아 출력을 내보내는 일련의 과정**이다. 프로그래밍 언어의 함수도 수학의 경우와 같은 개념이다.

프로그래밍 언어의 **함수는 일련의 과정을 문(statement)으로 구현하고 코드 블럭으로 감싸서 하나의 실행 단위로 정의한 것이다.**

### 함수의 구성 요소

---

이때 함수 내부로 입력을 전달 받는 변수를 `매개변수(parameter)`, 입력을 `인수(argument)`, 출력을 `반환값`이라 한다.

```jsx
function add(x, y) {
  // x와 y가 매개변수이다.
  return x + y; // x + y가 반환값이다.
}
add(2, 5); // 2와 5가 인수이다.
```

### 함수의 사용 이유

---

**함수는 필요할 때 여러 번 호출할 수 있다**. 중복된 역할을 하는 코드를 함수로 묶으면 `유지보수의 편의성`과 `코드의 신뢰성`을 높일 수 있다. 이 때 **함수 이름은 함수의 내부 코드를 이해하지 않고도 그 역할을 파악할 수 있는데 큰 도움**을 주기 때문에 **적절한 함수 네이밍이 중요**하다.

### 함수 정의

---

함수는 함수 정의를 통해 생성되는데, 이 때 함수 정의에는 4가지 방법이 있다.

1. 함수 선언문
2. 함수 표현식
3. Function 생성자 함수
4. 화살표 함수(ES6)

### 함수 선언문

---

함수 선언문의 형태는 다음과 같다.

```jsx
function add(x, y) {
  return x + y;
}
```

함수 선언문은 `표현식이 아닌 문`이다. 표현식이 아닌 문은 **변수에 할당할 수 없다**.

그러나 아래 코드를 보면 함수 선언문이 변수에 할당되는 것처럼 보인다.

```jsx
//함수 선언문이 변수에 할당되는 것처럼 보인다.
var add = function add(x, y) {
  return x + y;
};
```

이러한 동작 이유는 **함수명이 있는 함수 리터럴이 중의적인 코드**이기 때문이다.

중의적인 의미를 담고 있는 코드들이 있다. 예를 들어 { }은 블록문일 수도 있고, 객체 리터럴일 수도 있다. 자바스크립트 엔진은 이를 어떻게 구분할까? 정답은 **문맥을 보고 구분한다** 이다. { }이 단독으로 쓰이면 블록문이지만 값으로 평가되어야 할 문맥, 예를 들어 할당 연산자의 우변에 있다면 자바스크립트는 이를 객체 리터럴로 해석한다.

함수명이 있는 함수 리터럴도 마찬가지이다. 함수명이 있는 함수 리터럴을 **단독으로 사용하면 함수 선언문**으로 해석하고, 같은 함수를 **피연산자로 사용하면 함수 리터럴 표현식으로 해석**한다.

함수 선언문과 함수 리터럴 표현식이 생성되는 것은 동일하지만, **함수를 생성하는 내부 동작에 차이가 있다**.

```jsx
//함수 선언문
function foo() {
  console.log('foo');
}

//함수 리터럴
//그룹 연산자 ( )로 감싸져 있다.
(function bar() {
  console.log('bar');
});

console.log(foo()); // foo
console.log(bar()); // Reference Error
```

위와 같이 동작하는 이유는 **함수 리터럴에서 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자 이기 때문**이다. 위 코드의 함수 리터럴에서 `bar`는 bar()**{ } 내부에서만 참조할 수 있다**. 즉 위의 함수 리터럴은 **호출할 수 있는 식별자가 없는 상태**이다.

반면 함수 선언문의 `foo`는 해당 식별자로 함수를 호출할 수 있다. 이는 함수 선언문의 경우 **자바스크립트 엔진이 암묵적으로 함수 이름을 함수 식별자로 생성하고, 거기에 함수 객체를 할당하기 때문이다**. 위 함수 선언문을 의사 코드로 나타내면 다음과 같다.

```jsx
var foo = function foo() {
  console.log('foo');
};
```

사실 이 코드는 다음에 볼 `함수 표현식`과 형태적으로 동일하다. **결론적으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환**한다고 할 수 있다. **단 함수 선언문과 함수 표현식이 정확히 동일하게 동작하는 것은 아니다.**

### 함수 표현식

---

자바스크립트의 함수는 `일급 객체`이다. [(일급 객체란?)](https://github.com/woowacourse-study/2022-book-muscle/blob/main/modern-javascript-deep-dive/hui/ch10_%EA%B0%9D%EC%B2%B4_%EB%A6%AC%ED%84%B0%EB%9F%B4.md)

함수가 일급 객체라는 것은 **함수를 값처럼 자유롭게 사용할 수 있다는 의미**다. 그렇기 때문에 **함수 리터럴로 생성한 함수 객체를 변수에 할당**할 수 있다. 이러한 정의 방식을 `함수 표현식` 이라고 한다.

```jsx
//함수 표현식
//함수 리터럴의 함수 이름은 생략 가능
//함수 표현식의 함수 리터럴은 이름을 생략하는 것이 일반적이다.
var add = function (x, y) {
  return x + y;
};

console.log(add(2, 5)); //7
```

앞서 함수 선언문과 함수 표현식이 정확히 동일하게 동작하지는 않는다고 했다. 그 차이를 알아보자.

함수 생성 시점과 함수 호이스팅

```jsx
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

//함수 선언문
function add(x, y) {
  return x + y;
}

//함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

위와 같이 동작하는 이유는 **함수 선언문과 함수 표현식의 생성 시점이 다르기 때문**이다.

함수 선언문은 `함수 호이스팅`이 된다. 함수 선언문으로 함수를 정의하면 **런타임 이전에 함수 객체가 먼저 생성**된다. 이 때문에 코드가 한 줄 씩 차례대로 실행되기 시작하는 **런타임에는 이미 함수를 참조할 수 있는 상태가 완료**돼, 함수를 호출할 수 있는 것이다.

반면 **함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문**이다. 따라서 이 경우에는 `변수 호이스팅`이 발생한다. 변수 호이스팅은 런타임 이전에 변수가 선언되고, **런타임 시에 변수에 값이 할당되는 방식**이다. 이 때문에 함수 표현식 이전에 함수를 참조하면 `undefined`가 나온다. undefined를 함수로 호출하려고 하니 TypeError가 발생하는 것이다. 따라서 **함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 한다.**

//Function 생성자 함수, 계속...
